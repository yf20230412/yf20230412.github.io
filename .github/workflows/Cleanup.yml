# é«˜æ•ˆæ¸…ç†æ—§å·¥ä½œæµè®°å½•
name: Cleanup Old Workflows (Batch)
on:
  schedule:
    - cron: '0 1 */3 * *'  # æ¯3å¤©å‡Œæ™¨1ç‚¹è¿è¡Œ
  workflow_dispatch:

permissions:
  actions: write  # éœ€è¦åˆ é™¤å·¥ä½œæµçš„æƒé™

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cleanup in Batches
        uses: actions/github-script@v6
        env:
          RETENTION_DAYS: 1  # ä¿ç•™æœ€è¿‘1å¤©çš„è®°å½•
          BATCH_SIZE: 30     # æ¯æ‰¹æ¬¡å¤„ç†30æ¡
          MAX_PAGES: 5       # æœ€å¤šæ£€æŸ¥5é¡µï¼ˆé˜²æ­¢è¶…é™ï¼‰
        with:
          script: |
            const { RETENTION_DAYS, BATCH_SIZE, MAX_PAGES } = process.env;
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - parseInt(RETENTION_DAYS));

            let deletedCount = 0;
            let page = 1;

            while (page <= parseInt(MAX_PAGES)) {
              console.log(`ğŸ“– æ­£åœ¨æ£€æŸ¥ç¬¬ ${page} é¡µ...`);
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: parseInt(BATCH_SIZE),
                page: page,
                status: 'completed',
              });

              if (runs.workflow_runs.length === 0) break;

              for (const run of runs.workflow_runs) {
                if (new Date(run.created_at) < cutoffDate) {
                  try {
                    await github.rest.actions.deleteWorkflowRun({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      run_id: run.id,
                    });
                    deletedCount++;
                    console.log(`â™»ï¸ å·²åˆ é™¤ #${run.id} (${run.created_at})`);
                    
                    // æ¯åˆ é™¤10æ¡æš‚åœ15ç§’ï¼Œé¿å…è§¦å‘é€Ÿç‡é™åˆ¶
                    if (deletedCount % 10 === 0) {
                      await new Promise(resolve => setTimeout(resolve, 15000));
                    }
                  } catch (error) {
                    console.error(`âŒ åˆ é™¤ #${run.id} å¤±è´¥: ${error.message}`);
                  }
                }
              }

              page++;
              // æ¯å¤„ç†å®Œä¸€é¡µæš‚åœ20ç§’
              await new Promise(resolve => setTimeout(resolve, 20000));
            }

            console.log(`âœ… æ€»è®¡åˆ é™¤ ${deletedCount} æ¡æ—§è®°å½•`);